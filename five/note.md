1. node中有一个基类：EventEmitter。我们可以利用这个基类来创建自定义事件的发射器。
2. 理解事件发射器模式
    在标准的回调模式中，将一个回调函数传递给一个执行的函数，当函数执行完成之后，需要通知客户端的情况下，这种模式工作的很好。但是如果函数执行的过程中发生了多个事件或者事件被触发了多次，那这种模式就工作的不是很好了。这个时候，我们就需要采用我们的事件发射器模式。
    
    当我们在使用事件发射器的时候，需要涉及到多个对象，这些对象里面包括事件发射器或者一个或多个事件监听器
    
    事件发射器：就是可以发射事件的对象
    事件监听器：绑定到事件发射器上的代码，负责监听特定类型的事件
    (参考:http.js)
    
    一般性而言，当我们需要在请求操作完成后需要获取控制权的时候，我们就需要使用回调函数的模式。当事件可能发生多次的时候就需要使用事件发射器模式

3. 事件类型
    事件类型就是我们在构建事件发射器的时候，所指定的具体的事件类型。当有相关事件发生的时候，事件发射器就会调用相关的事件处理函数，并将相关数据作为参数传递给事件函数。
    
4. 应用事件的发射器API
    任何实现了事件发射器的对象，都实现了下面的几个方法：
        .addListener和.on：为指定类型的事件添加事件监听器
        .once：为指定类型的事件绑定一个仅会被调用一次的事件    监听器
        .removeListener：删除绑定到指定事件的某个指定的事件监听器
        .removeAllListeners：删除绑定到指定事件的所有的事件监听器
    
    一：addListener和on是等价的，都是为某些对象绑定指定的事件类型。
        如：为fs对象绑定data事件
            fs.addListener("data",callback)  ===>
            fs.on("data", callback)
        有一点我们需要清除的就是，传递给回调函数的参数取决于特定的事件类型。这些参数并没有被标准化
        
        我们可以给一个事件绑定多个事件监听器来监听同一类型的事件
        fs.addListener("data",callback1)
        fs.addListener("data",callback2)
        
        这些事件监听器按照所绑定的顺序来依次触发。这种行为说明了两个简单的道理：
            某个事件监听器，并不会在事件发射之后立即被调用，因为在它之前可能有别的事件监听器正在被调用
            如果某个事件监听器在调用的过程中触发了错误，可能会导致一些事件监听器永远都不会被调用。而且，事件监听器还有可能会捕获并处理它们
        
    二：使用removeListener从事件发射器中删除一个事件:
        这个方法要同时指定事件类型和事件监听器。一般不要放在某个回调函数中，否则有可能不起作用
    
    三：我们可以使用once这个方法来监听最多发生一次的事件，或者只对某个事件第一次发生的时候感兴趣
        
    四：我们可以使用removeAllListeners()从事件发射器中删除所有的事件监听器
        基本使用：emitter.removeAllListeners(type)

5. 创建事件发射器
    nodejs中创建事件发射器，我们一般使用的是EventEmitter这个基类，同时，我们也能够从这个基类继承，从而创建自己的事件发射器基类。
    const EventEmitter = require("events").EventEmitter;
    
6. 发射事件
    发射事件我们使用的是emit方法，这个方法的第一个参数就是我们需要触发的事件类型，第二个以及后面的参数都是我们传递给事件监听程序函数的